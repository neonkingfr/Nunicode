#!/usr/bin/python
#-*- coding: UTF-8

from operator import itemgetter
import sys
import time

from coldata import *


def tab(s, tabs=1):
	return '\t' * tabs + s


def points2points(points):
	'''0000 to 000000 i.e. any-byte codepoints to 6-byte codepoints'''
	return ['%06X' % (int(point, base=16)) for point in points]


def collect_contractions(codepoints_file, contractions_file):
	codepoints = []
	contractions = []
	for line in open(codepoints_file, 'rt'):
		tokens = coldata_split(line)
		points, weight = points2points(tokens[:-1]), int(tokens[-1], base=16)
		codepoints.append((points, weight))

	for line in open(contractions_file, 'rt'):
		tokens = coldata_split(line)
		points, weight = points2points(tokens[:-1]), int(tokens[-1], base=16)
		contractions.append((points, weight))

	return sorted(codepoints, key=itemgetter(0)), sorted(contractions, key=itemgetter(0))


def state2str(codepoints):
	return 'state_' + '_'.join('%06X' % int(codepoint, base=16) for codepoint in codepoints)


def str2state(state):
	return state[len('state_'):].split('_')


def find_weight(codepoints, collection):
	for points, weight in collection:
		if points == codepoints:
			return weight


def find_children(state, contractions):
	children = []
	for s, w in contractions:
		if len(s) > len(state) and s[:len(state)] == state:
			children.append((s, w))
	return children


def find_parent(state, states):
	for s, w in states:
		s = str2state(s)
		if len(s) == len(state) - 1 and state[:-1] == s:
			return state2str(s)


def final_state(state, contractions):
	return not find_children(state, contractions)

def root_state(state):
	return len(state) == 1


def collect_states(contractions, codepoints):
	states = set()
	max_level = 0
	for points, _ in contractions:
		if len(points) < 2:
			continue

		for i in xrange(len(points) - 1):
			states.add(state2str(points[:i + 1]))
		states.add(state2str(points))

		max_level = max(len(points), max_level)

	s = [ (state, -(i + 1)) for i, state in enumerate(sorted(states)) ]

	for i, state_tuple in enumerate(s):
		state = str2state(state_tuple[0])
		if not final_state(state, contractions):
			continue

		state_weight = find_weight(state, contractions)
		assert(state_weight is not None)
		s[i] = (state_tuple[0], state_weight)

	return s, max_level


def expand_root_state(state):
	print tab('if (u == 0x%06X) { return %s; }' % (int(state[0], base=16), state2str(state)))


def expand_root_states(states, max_level):
	print 'if (*w == 0) { /* root states */'

	for state_str, weight in states:
		state = str2state(state_str)
		if len(state) > 1:
			continue

		expand_root_state(state)

	print '}'
	print


def find_closest_parent(state, states):
	closest_parent = []
	for s, w in states:
		s = str2state(s)
		if len(s) < len(state) and state[:len(s)] == s:
			closest_parent = len(s) > len(closest_parent) and s or closest_parent

	return closest_parent or None  # return None instead of empty list


def fallback(state, states, contractions, codepoints):
	parent = root_state(state) and state or find_closest_parent(state, states)
	assert(parent is not None)
	weight = find_weight(parent, contractions) or find_weight(parent, codepoints)
	assert(weight is not None)
	distance = len(state) - len(parent) + 1
	assert(distance >= 1)

	print tab('*w = %d; /* fallback */' % (distance), 2)
	print tab('return %d;' % (weight), 2)


def expand_children(state, states, contractions, codepoints):
	children = set([tuple(child[:len(state) + 1]) for child, _ in find_children(state, contractions)])
	children = list(list(child) for child in children)
	assert(children)

	print tab('switch (u) {', 2)

	for i, next_state in enumerate(children):
		assert(len(next_state) > len(state))

		check_codepoint = next_state[-1]
		weight = final_state(next_state, contractions) and str(find_weight(next_state, contractions)) or state2str(next_state)

		print tab('case 0x%06X: return %s; ' % (int(check_codepoint, base=16), weight), 2)

	print tab('}', 2)
	print

	fallback(state, states, contractions, codepoints)


def expand_non_root_state((state, weight), states, contractions, codepoints):
	# final states will be expanded inside intermediate states
	if final_state(state, contractions):
		return

	state_str = state2str(state)

	print tab('if (weight == %s) {' % (state_str))
	expand_children(state, states, contractions, codepoints)
	print tab('}')


def expand_non_root_states(states, max_level, contractions, codepoints):
	print 'if (*w != 0) {'
	print tab('int32_t weight = *w;')
	print tab('*w = 0');
	print

	for state_str, weight in states:
		state = str2state(state_str)
		expand_non_root_state((state, weight), states, contractions, codepoints)

	print '}'
	print


def usage():
	print 'usage: ' + sys.argv[0] + ' [CODEPOINTS] [CONTRACTIONS]'
	print
	print '[CODEPOINTS]   - filename with list of codepoints'
	print '[CONTRACTIONS] - filename with list of contractions from the same collation'


if __name__ == '__main__':
	if len(sys.argv) < 3:
		usage()
		sys.exit(1)

	codepoints_file, contractions_file = sys.argv[1], sys.argv[2]
	codepoints, contractions = collect_contractions(codepoints_file, contractions_file)
	states, max_level = collect_states(contractions, codepoints)
	expand_root_states(states, max_level)
	expand_non_root_states(states, max_level, contractions, codepoints)
