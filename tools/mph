#!/usr/bin/python
# Easy Perfect Minimal Hashing
#
# Based on:
# By Steve Hanov. Released to the public domain.
# http://stevehanov.ca/blog/index.php?id=119
#
# Based on:
# Edward A. Fox, Lenwood S. Heath, Qi Fan Chen and Amjad M. Daoud,
# "Practical minimal perfect hash functions for large databases",
# CACM, 35(1):105-121
#
# also a good reference:
# Compress, Hash, and Displace algorithm by Djamal Belazzougui,
# Fabiano C. Botelho, and Martin Dietzfelbinger

import sys
import time

FNV_OFFSET_BASIS = 0xffffffff
FNV_PRIME = 0x01000193


# Calculates a distinct hash function for a given string. Each value of the
# integer d results in a different hash value.
def hash(d, str):
	if d == 0:
		d = FNV_PRIME

	# Use the FNV algorithm from http://isthe.com/chongo/tech/comp/fnv/
	c = int(str, base=16)
	c1 = c & 0xFF000000
	c2 = c & 0x00FF0000
	c3 = c & 0x0000FF00
	c4 = c & 0x000000FF

	d = (((d * FNV_PRIME) ^ c1) & FNV_OFFSET_BASIS)
	d = (((d * FNV_PRIME) ^ c2) & FNV_OFFSET_BASIS)
	d = (((d * FNV_PRIME) ^ c3) & FNV_OFFSET_BASIS)
	d = (((d * FNV_PRIME) ^ c4) & FNV_OFFSET_BASIS)

	return d


# Computes a minimal perfect hash table using the given python dictionary. It
# returns a tuple (G, V). G and V are both arrays. G contains the intermediate
# table of values needed to compute the index of the value in V. V contains the
# values of the dictionary.
def CreateMinimalPerfectHash(dict):
	size = len(dict)

	# Step 1: Place all of the keys into buckets
	buckets = [[] for i in range(size)]
	G = [0] * size
	values = [None] * size

	for key in dict.keys():
		buckets[hash(0, key) % size].append(key)

	# Step 2: Sort the buckets and process the ones with the most items first.
	buckets.sort(key=len, reverse=True)
	for b in xrange(size):
		bucket = buckets[b]
		if len(bucket) <= 1:
			break

		d = 1
		item = 0
		slots = []

		# Repeatedly try different values of d until we find a hash function
		# that places all items in the bucket into free slots
		while item < len(bucket):
			slot = hash(d, bucket[item]) % size
			if values[slot] is not None or slot in slots:
				d += 1
				item = 0
				slots = []
			else:
				slots.append(slot)
				item += 1

		G[hash(0, bucket[0]) % size] = d
		for i in range(len(bucket)):
			values[slots[i]] = dict[bucket[i]]

		if (b % 1000) == 0:
#            print "bucket %d    r" % (b),
			sys.stdout.flush()

	# Only buckets with 1 item remain. Process them more quickly by directly
	# placing them into a free slot. Use a negative value of d to indicate
	# this.
	freelist = []
	for i in xrange(size):
		if values[i] is None:
			freelist.append(i)

	for b in xrange(b, size):
		bucket = buckets[b]

		if len(bucket) == 0:
			break

		slot = freelist.pop()
		# We subtract one to ensure it's negative even if the zeroeth slot was
		# used.
		G[hash(0, bucket[0]) % size] = -slot - 1
		values[slot] = dict[bucket[0]]
		if (b % 1000) == 0:
#            print "bucket %d    r" % (b),
			sys.stdout.flush()

	return (G, values)


# Look up a value in the hash table, defined by G and V.
def PerfectHashLookup(G, key):
	d = G[hash(0, key) % len(G)]
	if d < 0:
		return -d - 1
	return hash(d, key) % len(G)


# Print human-readable info regarding this hash-table
def GenerateInfo(G):
	print '''/*
%d
FNV_OFFSET_BASIS: %08X,
FNV_PRIME: %08X,
FNV_SIZE: %d
*/''' % (time.time(), FNV_OFFSET_BASIS, FNV_PRIME, len(G))


# Filter out non-characters from private area
def Pass(c):
	return (ord(c) < 0xE000 or ord(c) > 0xF8FF)


# Produce C-source-ready decomposition string
def FormatReplacement(r):
	chars = u''.join(
		filter(Pass, [unichr(int(x, base=16)) for x in r])).encode('utf-8')
	return '"%s"' % (''.join(('\\x%02X' % (ord(x)) for x in chars)))

VALUE_TEMPLATE = '''	{ 0x%(codepoint)05X, %(decomps)s },'''
VALUE_REF_TEMPLATE = '''&V%(codepoint)05X'''


# Print values table
def GenerateValues(G, V):
	BOUNDARY = 6

	print 'static const nu_udb_t VALUES[] = {'
	for i, (codepoint, replacement) in enumerate(V):
		print VALUE_TEMPLATE % {
			'codepoint': int(codepoint, base=16),
			'decomps': FormatReplacement(replacement)
		}
	print '};'
	print


# Print first hash table
def GenerateFNV(G):
	BOUNDARY = 12

	print 'static const int16_t FNV[] = {'
	for i, x in enumerate(G):
		if i % BOUNDARY == 0:
			sys.stdout.write('\t')
		sys.stdout.write(str(x))
		sys.stdout.write(', ')
		if (i + 1) % BOUNDARY == 0:
			sys.stdout.write('\n')
	print '};'
	print

dict = {}
list = []

for i, line in enumerate(sys.stdin):
	codepoint, replacement = line.split(' ')
	dict[codepoint] = (codepoint, replacement.strip().split(','))
	list.append(codepoint)

(G, V) = CreateMinimalPerfectHash(dict)

assert(len(G) == len(V))

GenerateInfo(G)
GenerateFNV(G)
GenerateValues(G, V)

#h = PerfectHashLookup(G, '0061')
#print 'hash:', h, V[h]
