#!/usr/bin/python
# Easy Perfect Minimal Hashing 
#
# Based on:
# By Steve Hanov. Released to the public domain.
# http://stevehanov.ca/blog/index.php?id=119
#
# Based on:
# Edward A. Fox, Lenwood S. Heath, Qi Fan Chen and Amjad M. Daoud, 
# "Practical minimal perfect hash functions for large databases", CACM, 35(1):105-121
# also a good reference:
# Compress, Hash, and Displace algorithm by Djamal Belazzougui,
# Fabiano C. Botelho, and Martin Dietzfelbinger

import sys

FNV_OFFSET_BASIS = 0xffffffff
FNV_PRIME = 0x01000193

# Calculates a distinct hash function for a given string. Each value of the
# integer d results in a different hash value.
def hash( d, str ):
    if d == 0: d = FNV_PRIME

    # Use the FNV algorithm from http://isthe.com/chongo/tech/comp/fnv/ 
    c = int(str, base=16)
    c1 = c & 0xFF000000
    c2 = c & 0x00FF0000
    c3 = c & 0x0000FF00
    c4 = c & 0x000000FF
    
    d = (( (d * FNV_PRIME) ^ c1 ) & FNV_OFFSET_BASIS)
    d = (( (d * FNV_PRIME) ^ c2 ) & FNV_OFFSET_BASIS)
    d = (( (d * FNV_PRIME) ^ c3 ) & FNV_OFFSET_BASIS)
    d = (( (d * FNV_PRIME) ^ c4 ) & FNV_OFFSET_BASIS)

    return d

# Computes a minimal perfect hash table using the given python dictionary. It
# returns a tuple (G, V). G and V are both arrays. G contains the intermediate
# table of values needed to compute the index of the value in V. V contains the
# values of the dictionary.
def CreateMinimalPerfectHash( dict ):
    size = len(dict)

    # Step 1: Place all of the keys into buckets
    buckets = [ [] for i in range(size) ]
    G = [0] * size
    values = [None] * size
    
    for key in dict.keys():
        buckets[hash(0, key) % size].append( key )

    # Step 2: Sort the buckets and process the ones with the most items first.
    buckets.sort( key=len, reverse=True )        
    for b in xrange( size ):
        bucket = buckets[b]
        if len(bucket) <= 1: break
        
        d = 1
        item = 0
        slots = []

        # Repeatedly try different values of d until we find a hash function
        # that places all items in the bucket into free slots
        while item < len(bucket):
            slot = hash( d, bucket[item] ) % size
            if values[slot] != None or slot in slots:
                d += 1
                item = 0
                slots = []
            else:
                slots.append( slot )
                item += 1

        G[hash(0, bucket[0]) % size] = d
        for i in range(len(bucket)):
            values[slots[i]] = dict[bucket[i]]

        if ( b % 1000 ) == 0:
#            print "bucket %d    r" % (b),
            sys.stdout.flush()

    # Only buckets with 1 item remain. Process them more quickly by directly
    # placing them into a free slot. Use a negative value of d to indicate
    # this.
    freelist = []
    for i in xrange(size): 
        if values[i] == None: freelist.append( i )

    for b in xrange( b, size ):
        bucket = buckets[b]
        if len(bucket) == 0: break
        slot = freelist.pop()
        # We subtract one to ensure it's negative even if the zeroeth slot was
        # used.
        G[hash(0, bucket[0]) % size] = -slot-1 
        values[slot] = dict[bucket[0]]
        if ( b % 1000 ) == 0:
#            print "bucket %d    r" % (b),
            sys.stdout.flush()

    return (G, values)        

# Look up a value in the hash table, defined by G and V.
def PerfectHashLookup( G, key ):
    d = G[hash(0,key) % len(G)]
    if d < 0: return -d-1
    return hash(d, key) % len(G)

def Pass(c):
	# Filter out non-characters from private area
	return (ord(c) < 0xE000 or ord(c) > 0xF8FF)

def FormatReplacement( r ):
	chars = u''.join(filter(Pass, [ unichr(int(x, base=16)) for x in r ])).encode('utf-16le')
	# Append \0 to int16-align strings
	return '"%s\\x00"' % (''.join(( '\\x%02X' % (ord(x)) for x in chars )))

VALUE_TEMPLATE = '''static const nu_udb_t VAL_%(codepoint)08X = {
	0x%(codepoint)08X,
	%(decomps)s
};'''

VALUE_REF_TEMPLATE = '''&VAL_%(codepoint)08X'''

def GenerateValues( G, V ):
	BOUNDARY = 6

	for i, (codepoint, replacement) in enumerate(V):
		print VALUE_TEMPLATE % { 'codepoint': int(codepoint, base=16), 
		                         'decomps': FormatReplacement(replacement) }
		pass

	print
	print 'static const nu_udb_t* VALUES[] = {';
	for i, (codepoint, replacement) in enumerate(V):
		if i % BOUNDARY == 0:
		    sys.stdout.write('\t')
	
		hash = PerfectHashLookup( G, list[i] )
		sys.stdout.write('%s, ' % (VALUE_REF_TEMPLATE % { 'codepoint': int(codepoint, base=16) }))
		
		if (i + 1) % BOUNDARY == 0:
		    sys.stdout.write('\n')

	print
	print '};'
	print

def GenerateFNV( G ):
	BOUNDARY = 12
	
	print
	print 'static const uint16_t FNV[] = {'
	for i, x in enumerate(G):
		if i % BOUNDARY == 0:
		    sys.stdout.write('\t')
		sys.stdout.write(str(x))
		sys.stdout.write(', ')
		if (i + 1) % BOUNDARY == 0:
		    sys.stdout.write('\n')
	print
	print '};'
	print
    
dict = {}
list = []

for i, line in enumerate(sys.stdin):
    codepoint, replacement = line.split(' ')
    dict[codepoint] = (codepoint, replacement.strip().split(','))
    list.append(codepoint)

(G, V) = CreateMinimalPerfectHash( dict )

assert(len(G) == len(V))

GenerateFNV(G)
GenerateValues(G, V)
